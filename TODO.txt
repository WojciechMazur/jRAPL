
<< Immediate Todos:
	- whats wrong with JMH JNI overhead / compare results to full runtime	
	- finish the edits David asked for
	- Properly graph sampling efficiency
	- see your scrap paper list of todo

<< Semi Immediate Todos:
	- Run experiments on several computers
	- CSide-GetLastK grabs the correct number of samples, but samples being individual structs, not structs grouped by socket. look at the occasional segfault related to this
	- Get a complete lists of the benchmarks / more info about dacapo-evalution-git+309e1fa.jar

<< Other Todos:
	- Update the UML
	- figure out why -O{1,2,3} flags mess things up. Almost positive it's bc it optimizes out the assembly code required to getSocketNum() (as per my gdb run)
		- does compiling with clang cause a segfault on non debian machine?
		- where does the clang segfault happen? it's somewhere in AsyncEnergyMonitorCSide. easy enough to fix?
		- what exactly is the problem with clang and debian?

Ideas for future development:
	- Naming Conventions to Edit (and make sure they're good):
		; EnergyStamp (now what EnergyStats is)
		; EnergyStats (holds whatever aggregate you want, plus maybe a String identifying it and an instant/duration object)
		; EnergySample (for EnergyDiff)

	- Make C run on a schedule instead of sleeping, so sampling overhead of 130-170usec (on jolteon, at least) isn't an issue for high rates.
		- See timer implementation, or the thing Timur sent: https://github.com/jvm-profiling-tools/async-profiler/blob/master/src/itimer.cpp
	- Make the AsyncMonitor have an 'auto dump' file, then have it dump its content to file (on a separate thread) and clear out.
		To make it not indefinitely grow in memory
	- AsyncMonitor runs a set number of samples at a rate, instead of a start/stop wait loop

	- EnergySample.dumps() and EnergySample.loads()

	- Instead of returning an EnergyStats object as a human readable string across the JNI, serialize the raw bits of the struct, return that
		as a string, and then write a java-side parsing function. That's probably going to be hard to write but the string brought across will
		be smaller, and it'll probably be less computation overall, unless if the Java hella-optimizes string splitting and atoi type computations


<< Have done by next week ## wednesday #:
	get 2 socket support down on jolteon -- like just the simple 1 string solution instead of breaking the string into 2 pieces when processing AsyncEnergyMonitor data
		make async monitors writeToFile or lastKSamples as multisocket things instead of breaking it up into per-socket things for each sample
	Plots that Timur asked for
	Implement some of the small, easily doable 'jRAPL improvements' that you came up with during the hackathon (like add a getter for timestamp)


Update the UML

IDEA for AsyncMonitor: set a maxCapacityUntilDump and when arraylist gets that full, start (another) thread to dump to file and clear out the current thing. to not puollute RAM too much. idk, maybe.
like you can have a second thread monitoring the capacity and then dumping as necessary. idk if it's a problem to implicitly spawn a second
thread. there might be a conventional method to deal with things growing in memory too often.


Make sure Java code is neat and well documented (at least the already written documentation is up to date),
	since we're pretty much done refactoring the core utilities, so it's important for it to be legible for presenting it

for AsyncMonitor experiments, add another info thing youre tracking for 'number of microseconds between nonzero readings'
  and make that a third plot for each dram/core/gpu/pkg (again, best to do it all in one fig
  of 4 subplots)

run thread experiments with 5 and 10 and 20 ms delay

Compare # of samples between C and Java

time between nonzero readings as a test that gets evaluated (based off of timestamps)

make the AsyncMonitor run a set number of operations   instead of start/stop wait loop
make the AsyncMonitor run a set number of milliseconds instead of start/stop wait loop

"timer" implemntation on the C side

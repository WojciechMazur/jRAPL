
<< Have done by next week ## wednesday #:
	- do one time series trace of jraplOn / jraplOff memory for sunflow
	- % difference when displaying comparative memory data
	- make graphs for the jmh time each sample result
	- make the aggregate memory-stats-per-benchmark table a good graphic instead of a bad LaTeX dump
	- figure out why optimization messes things up
		- does compiling with clang cause a segfault on non debian machine?
		- where does the clang segfault happen? it's somewhere in AsyncEnergyMonitorCSide. easy enough to fix?
		- what exactly is the problem with clang and debian?

<< Near future:
	- java version of sizeof(object) -- to compare between footprint of Object Sample and Primitive Sample

<< General Thoughts and Stuff to Eventually do:
	- EnergyStamp (now what EnergyStats is) ; EnergyStats (holds whatever aggregate you want, plus maybe a String identifying it and an instant/duration object) ; EnergyLapse (or other better name for EnergyDiff)


Update the UML

IDEA for AsyncMonitor: set a maxCapacityUntilDump and when arraylist gets that full, start (another) thread to dump to file and clear out the current thing. to not puollute RAM too much. idk, maybe.
like you can have a second thread monitoring the capacity and then dumping as necessary. idk if it's a problem to implicitly spawn a second
thread. there might be a conventional method to deal with things growing in memory too often.

make the AsyncMonitor run a set number of operations   instead of start/stop wait loop

"timer" implemntation on the C side -- could make the sleep_milliseconds() function more accurate
